From d6fb713cd22abeca146a983e7251f1aebc6f2693 Mon Sep 17 00:00:00 2001
From: Sebastian Keller <skeller@gnome.org>
Date: Tue, 23 Apr 2024 20:45:36 +0200
Subject: [PATCH] x11/window: Compare input shape to client rect when
 undecorating

When a window with an input shape on its decoration window becomes
undecorated and meta_window_x11_update_input_region() gets called via
notify::decorated, the buffer_rect of the window has not been updated
yet while the decorated property has. This would lead to us comparing
the input shape of the client window to the buffer_rect which still
includes the decoration window. This would fail to detect the common
case when the client window has no input shape set, leading to the input
region being set to the size of the client window rather than NULL. If
the window is then resized later, the input shape would remain at the
previous size.

This was not a problem before 6bd920b35, because then we were (wrongly)
always comparing to the client_rect.

Fix this by choosing the correct rect for comparison depending on
whether the window is decorated.

Fixes: 6bd920b35 ("x11/window: Use correct bounding rect to determine NULL input region")
Closes: https://gitlab.gnome.org/GNOME/mutter/-/issues/3451
---
 src/x11/window-x11.c | 16 +++++++---------
 1 file changed, 7 insertions(+), 9 deletions(-)

diff --git a/src/x11/window-x11.c b/src/x11/window-x11.c
index 210f4a1330..8afe619184 100644
--- a/src/x11/window-x11.c
+++ b/src/x11/window-x11.c
@@ -2400,6 +2400,7 @@ meta_window_x11_update_input_region (MetaWindow *window)
   g_autoptr (MtkRegion) region = NULL;
   MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
   MetaWindowX11Private *priv = meta_window_x11_get_instance_private (window_x11);
+  MtkRectangle bounding_rect = { 0 };
   Window xwindow;
 
   if (window->decorated)
@@ -2411,10 +2412,14 @@ meta_window_x11_update_input_region (MetaWindow *window)
           return;
         }
       xwindow = window->frame->xwindow;
+      bounding_rect.width = window->buffer_rect.width;
+      bounding_rect.height = window->buffer_rect.height;
     }
   else
     {
       xwindow = priv->xwindow;
+      bounding_rect.width = priv->client_rect.width;
+      bounding_rect.height = priv->client_rect.height;
     }
 
   if (META_X11_DISPLAY_HAS_SHAPE (x11_display))
@@ -2458,8 +2463,8 @@ meta_window_x11_update_input_region (MetaWindow *window)
       else if (n_rects == 1 &&
                (rects[0].x == 0 &&
                 rects[0].y == 0 &&
-                rects[0].width == window->buffer_rect.width &&
-                rects[0].height == window->buffer_rect.height))
+                rects[0].width == bounding_rect.width &&
+                rects[0].height == bounding_rect.height))
         {
           /* This is the bounding region case. Keep the
            * region as NULL. */
@@ -2476,13 +2481,6 @@ meta_window_x11_update_input_region (MetaWindow *window)
 
   if (region != NULL)
     {
-      MtkRectangle bounding_rect;
-
-      bounding_rect.x = 0;
-      bounding_rect.y = 0;
-      bounding_rect.width = window->buffer_rect.width;
-      bounding_rect.height = window->buffer_rect.height;
-
       /* The shape we get back from the client may have coordinates
        * outside of the frame. The X SHAPE Extension requires that
        * the overall shape the client provides never exceeds the
-- 
GitLab

